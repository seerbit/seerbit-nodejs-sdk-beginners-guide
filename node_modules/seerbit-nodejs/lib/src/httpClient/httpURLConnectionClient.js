"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const https_1 = require("https");
const https_proxy_agent_1 = require("https-proxy-agent");
const url_1 = require("url");
const httpClientException_1 = __importDefault(require("./httpClientException"));
const apiException_1 = __importDefault(require("../services/exception/apiException"));
const apiConstants_1 = require("../constants/apiConstants");
class HttpURLConnectionClient {
    request(endpoint, json, config, requestOptions) {
        requestOptions.headers = {};
        requestOptions.timeout = config.connectionTimeoutMillis;
        // const secretKey = config.secretKey;
        const bearerToken = config.bearerToken;
        // const publicKey = config.publicKey;
        if (requestOptions.isTokenRequired && !bearerToken) {
            return Promise.reject(new apiException_1.default("SeerBit Merchant API Token is required", 401));
        }
        if (requestOptions.isTokenRequired && config.bearerToken) {
            requestOptions.headers[apiConstants_1.ApiConstants.AUTHORIZATION] = "Bearer " + bearerToken;
        }
        else {
            // const authString = `${config.username}:${config.password}`;
            const authString = "h";
            const authStringEnc = Buffer.from(authString, "utf8").toString("base64");
            requestOptions.headers.Authorization = `Basic ${authStringEnc}`;
        }
        // if (secretKey) {
        //     // requestOptions.headers[ApiConstants.SECRET_KEY] = secretKey;
        // }
        // if (publicKey) {
        //     // requestOptions.headers[ApiConstants.PUBLIC_KEY] = publicKey;
        // }
        requestOptions.headers[apiConstants_1.ApiConstants.CONTENT_TYPE] = apiConstants_1.ApiConstants.APPLICATION_JSON_TYPE;
        const httpConnection = this.createRequest(endpoint, requestOptions, json);
        return this.doPostRequest(httpConnection, json);
    }
    post(endpoint, postParameters, config) {
        const postQuery = this.getQuery(postParameters);
        const connectionRequest = this.createRequest(endpoint, {});
        return this.doPostRequest(connectionRequest, postQuery);
    }
    createRequest(endpoint, requestOptions, json) {
        if (!requestOptions.headers) {
            requestOptions.headers = {};
        }
        let buildEndpoint;
        if (json != null) {
            buildEndpoint = !requestOptions.isPost ? JSON.parse(json).query : "";
        }
        let url = new url_1.URL(endpoint);
        if (buildEndpoint != null) {
            url = new url_1.URL(endpoint + buildEndpoint);
        }
        requestOptions.hostname = url.hostname;
        requestOptions.protocol = url.protocol;
        requestOptions.port = url.port;
        requestOptions.path = url.pathname;
        if (this.proxy && this.proxy.host) {
            const { host, port, ...options } = this.proxy;
            requestOptions.agent = new https_proxy_agent_1.HttpsProxyAgent({ host, port: port || 443, ...options });
        }
        else {
            requestOptions.agent = new https_1.Agent(this.agentOptions);
        }
        requestOptions.headers["Cache-Control"] = "no-cache";
        requestOptions.method = requestOptions.isPost ? apiConstants_1.ApiConstants.METHOD_POST : apiConstants_1.ApiConstants.METHOD_GET;
        requestOptions.headers[apiConstants_1.ApiConstants.ACCEPT_CHARSET] = HttpURLConnectionClient.CHARSET;
        // requestOptions.headers[ApiConstants.USER_AGENT] = `${applicationName} ${Client.LIB_NAME}/${Client.LIB_VERSION}`;
        return https_1.request(requestOptions);
    }
    getQuery(params) {
        return params.map(([key, value]) => `${key}=${value}`).join("&");
    }
    doPostRequest(connectionRequest, json) {
        return new Promise((resolve, reject) => {
            connectionRequest.flushHeaders();
            connectionRequest.on("response", (res) => {
                const response = {
                    statusCode: res.statusCode,
                    headers: res.headers,
                    body: ""
                };
                const getException = (responseBody) => new httpClientException_1.default({
                    message: `HTTP Exception: ${response.statusCode}. ${res.statusMessage}`,
                    statusCode: response.statusCode,
                    errorCode: undefined,
                    responseHeaders: response.headers,
                    responseBody,
                });
                let exception = getException(response.body.toString());
                res.on("data", (chunk) => {
                    response.body += chunk;
                });
                res.on("end", () => {
                    if (!res.complete) {
                        reject(new Error("The connection was terminated while the message was still being sent"));
                    }
                    if (res.statusCode && (res.statusCode < 200 || res.statusCode >= 300)) {
                        try {
                            const formattedData = JSON.parse(response.body);
                            const isApiError = "status" in formattedData;
                            const isRequestError = "errors" in formattedData;
                            if (isApiError) {
                                exception = new httpClientException_1.default({
                                    message: `HTTP Exception: ${formattedData.status}. ${res.statusMessage}: ${formattedData.message}`,
                                    statusCode: formattedData.status,
                                    errorCode: formattedData.errorCode,
                                    responseHeaders: res.headers,
                                    responseBody: response.body,
                                });
                            }
                            else if (isRequestError) {
                                exception = new Error(response.body);
                            }
                            else {
                                exception = getException(response.body);
                            }
                        }
                        catch (e) {
                            reject(exception);
                        }
                        finally {
                            reject(exception);
                        }
                    }
                    resolve(response.body);
                });
                res.on("error", reject);
            });
            connectionRequest.on("timeout", () => {
                connectionRequest.abort();
            });
            connectionRequest.on("error", (e) => { console.log("error"); reject(new apiException_1.default(e.message)); });
            connectionRequest.write(Buffer.from(json));
            connectionRequest.end();
        });
    }
}
HttpURLConnectionClient.CHARSET = "utf-8";
exports.default = HttpURLConnectionClient;
//# sourceMappingURL=httpURLConnectionClient.js.map